--사용자 아이디가 jun123인 학생과 같은 학년인 학생의 학번,이름,학년을 조회

SELECT STUDNO,NAME,GRADE FROM STUDENT s  WHERE GRADE = 
(SELECT GRADE FROM STUDENT WHERE USERID  = 'jun123');

--101 번 학과 학생들의 평균 몸무게보다 적은 몸무게를 가진 학생의 학번,학과번호,몸무게를 조회


SELECT * FROM STUDENT s WHERE  WEIGHT <
(SELECT AVG(WEIGHT) FROM STUDENT s WHERE DEPTNO = 101);

-- 20101 번 학생과 학년이 같고 키는 20101번 학생보다 큰학생의 이름,학년,키를 구하여라

SELECT NAME ,GRADE ,HEIGHT FROM STUDENT WHERE GRADE =
(SELECT GRADE FROM STUDENT s WHERE STUDNO = 20101) AND HEIGHT >
(SELECT HEIGHT FROM STUDENT s WHERE STUDNO = 20101);

--정보 미디어학부에 소속된 학생의 학번,이름,학과번호 조회
SELECT STUDNO,NAME,DEPTNO FROM STUDENT WHERE DEPTNO IN(
SELECT DEPTNO FROM DEPARTMENT d WHERE COLLEGE =  
(SELECT DEPTNO FROM DEPARTMENT d WHERE DNAME = '정보미디어학부'));


SELECT * FROM STUDENT s WHERE HEIGHT > ANY (SELECT HEIGHT FROM STUDENT WHERE GRADE = 4);

SELECT HEIGHT FROM STUDENT s WHERE HEIGHT >
(SELECT MIN(HEIGHT) FROM STUDENT s WHERE GRADE =4);

--4학년 학생중에서 키가 가장 큰 학생보다 큰 학생을 조회, 학번 이름 키 
SELECT DEPTNO,NAME ,HEIGHT FROM STUDENT WHERE HEIGHT >ALL
(SELECT HEIGHT FROM STUDENT s WHERE  GRADE =4);

SELECT DEPTNO,NAME ,HEIGHT FROM STUDENT WHERE HEIGHT >
(SELECT MAX(HEIGHT) FROM STUDENT s WHERE  GRADE =4);

---보직 수당을 받는 교수가 존재한다면 교수들의 번호,이름,수당,급여+수당 을조회

SELECT PROFNO,NAME,SAL,SAL+NVL(COMM,0)SALCOM FROM PROFESSOR p WHERE EXISTS
(SELECT * FROM PROFESSOR p WHERE COMM IS NOT NULL);

SELECT PROFNO,NAME,SAL,SAL+NVL(COMM,0)SALCOM FROM PROFESSOR p WHERE EXISTS
(SELECT * FROM PROFESSOR p WHERE 1=1);
--------------------------------다중컬럼---------------------서브쿼리---------------------------

-- 학년별 체중이 최소인 학생의 이름, 학년, 체중을 조회

SELECT WEIGHT,NAME,GRADE FROM STUDENT s  WHERE (GRADE,WEIGHT) IN
(SELECT GRADE , MIN(WEIGHT) FROM STUDENT s GROUP BY GRADE) ; 


SELECT NAME,GRADE,WEIGHT FROM STUDENT s WHERE GRADE IN
(SELECT DISTINCT GRADE FROM STUDENT s ) AND WEIGHT IN
(SELECT MIN(WEIGHT) FROM STUDENT s GROUP BY GRADE);

SELECT NAME,GRADE,WEIGHT FROM STUDENT s WHERE GRADE IN
(SELECT DISTINCT GRADE FROM STUDENT s ) AND WEIGHT IN
(SELECT MIN(WEIGHT) FROM STUDENT s GROUP BY GRADE);

--학과 별 평균 키 보다 큰 학생의 , 이름 학과번호 키를 조회

SELECT NAME,DEPTNO,HEIGHT FROM STUDENT s1 WHERE HEIGHT >
(SELECT AVG(HEIGHT) FROM STUDENT s2 WHERE s2.DEPTNO = s1.DEPTNO) ;

SELECT DEPTNO ,AVG(HEIGHT) FROM STUDENT s GROUP BY DEPTNO ;

SELECT AVG(HEIGHT) FROM STUDENT s WHERE DEPTNO = 101;

SELECT MAX(SUN),MAX(MON) FROM(
SELECT 1 SUN, NULL MON,NULL ,NULL ,NULL ,NULL ,NULL  FROM DUAL
UNION
SELECT NULL ,2,NULL ,NULL ,NULL ,NULL ,NULL  FROM DUAL
);

SELECT MOD(30,7) FROM DUAL;

SELECT 
	MAX(DECODE(MOD(RN,7), 1,RN)) SUN
	,MAX(DECODE(MOD(RN,7), 2,RN)) MON
	,MAX(DECODE(MOD(RN,7), 3,RN)) TUS
	,MAX(DECODE(MOD(RN,7), 4,RN)) WED
	,MAX(DECODE(MOD(RN,7), 5,RN)) THU
	,MAX(DECODE(MOD(RN,7), 6,RN)) FRI
	,MAX(DECODE(MOD(RN,7), 0,RN)) SAT 
FROM(
	SELECT ROWNUM RN, TO_CHAR(TO_DATE('2024-09-' || LTRIM( TO_CHAR(ROWNUM,'00'))), 'W') WEEK
	FROM DICT 
	WHERE ROWNUM <= TO_CHAR(LAST_DAY(TO_DATE('2024-09','YYYY-MM')), 'DD')
)
GROUP BY week
ORDER BY WEEK;
--SELECT TO_CHAR(TO_DATE('2024-09','YYYY-MM-DD'),'W') FROM DUAL;

--DML
SELECT * FROM STUDENT s ;

INSERT INTO STUDENT VALUES(10110,'홍길동','hong','1','8501011143098','85/01/01','041)123-4567',170,70,101,9903);

SELECT * FROM USER_TAB_COLS WHERE TABLE_NAME = 'STUDENT';

SELECT COLUMN_NAME,COLUMN_ID FROM USER_TAB_COLS WHERE TABLE_NAME = 'STUDENT';

SELECT * FROM STUDENT s ;

ROLLBACK;

COMMIT;
SELECT * FROM DEPARTMENT d ;
INSERT INTO DEPARTMENT(DEPTNO,DNAME,COLLEGE) VALUES(300,'생명공학부','');

-- US_EN,UK_EN,

INSERT INTO PROFESSOR(PROFNO,NAME,POSITION,HIREDATE,DEPTNO) VALUES ( 9920,'최윤식','조교수',TO_DATE('2006-01-01','YYYY-MM-DD'),102);
SELECT * FROM PROFESSOR p ;
DELETE FROM PROFESSOR WHERE PROFNO = 9910;

INSERT INTO PROFESSOR VALUES (9910,'백미선','white','전임강사',200,TRUNC(SYSDATE),10,101);

-- 학생(STUDENT)과 동일한 테이블 생성,단 데이터 없음
CREATE TABLE T_STUDENT AS 
SELECT * FROM STUDENT WHERE 1=0 ;

SELECT * FROM T_STUDENT;

INSERT INTO T_STUDENT
SELECT * FROM STUDENT;

CREATE TABLE HEIGHT_INFO AS
SELECT  STUDNO,NAME,HEIGHT FROM STUDENT s WHERE 1=0; 

CREATE TABLE WEIGHT_INFO AS
SELECT  STUDNO,NAME,HEIGHT AS WEIGHT FROM STUDENT s WHERE 1=0; 

DROP TABLE WEIGHT_INFO ;
DROP TABLE HEIGHT_INFO ;

SELECT  * FROM HEIGHT_INFO ;
SELECT  * FROM WEIGHT_INFO;

TRUNCATE TABLE HEIGHT_INFO ;
TRUNCATE TABLE WEIGHT_INFO ;

--2학년 이상의 학생,HEIGHT _INFO에는 학번,이름, 키 , WEIGHT_INFO에는 학번 이름 체중을 입력
INSERT ALL
INTO HEIGHT_INFO(STUDNO,NAME,HEIGHT) VALUES (STUDNO,NAME,HEIGHT)
INTO WEIGHT_INFO VALUES (STUDNO,NAME,WEIGHT)
SELECT STUDNO,NAME,HEIGHT,WEIGHT FROM STUDENT s WHERE GRADE >=2;

INSERT FIRST
WHEN HEIGHT >= 170 THEN
INTO HEIGHT_INFO(STUDNO,NAME,HEIGHT) VALUES (STUDNO,NAME,HEIGHT)
WHEN WEIGHT >= 70 THEN
INTO WEIGHT_INFO VALUES (STUDNO,NAME,WEIGHT)
SELECT * FROM STUDENT s WHERE GRADE >=2;


--PIVOTING
CREATE TABLE SALES(
	SALES_NO NUMBER,
	WEEK_NO NUMBER,
	SALES_MON NUMBER,
	SALES_TUE NUMBER,
	SALES_WED NUMBER,
	SALES_THU NUMBER,
	SALES_FRI NUMBER
);

CREATE TABLE SALES_DATE(
	SALES_NO NUMBER,
	WEEK_NO NUMBER,
	DAY_NO NUMBER,
	SALES NUMBER
);

INSERT INTO SALES VALUES (1101,4,100,150,80,60,120);
INSERT INTO SALES VALUES(1102,5,300,300,230,120,150);

TRUNCATE TABLE SALES_DATE;
INSERT  ALL
INTO SALES_DATE VALUES(SALES_NO,WEEK_NO,1,SALES_MON)
INTO SALES_DATE VALUES(SALES_NO,WEEK_NO,2,SALES_TUE)
INTO SALES_DATE VALUES(SALES_NO,WEEK_NO,3,SALES_WED)
INTO SALES_DATE VALUES(SALES_NO,WEEK_NO,4,SALES_THU)
INTO SALES_DATE VALUES(SALES_NO,WEEK_NO,5,SALES_FRI)
SELECT * FROM SALES;

SELECT * FROM SALES_DATE sd 

SELECT * FROM SALES_DATE sd ;

SELECT
SALES_NO,
WEEK_NO,
MAX(DECODE(DAY_NO,1,SALES))M,
MAX( DECODE(DAY_NO,2,SALES))T,
MAX(DECODE(DAY_NO,3,SALES))W,
MAX(DECODE(DAY_NO,4,SALES))TH,
MAX(DECODE(DAY_NO,5,SALES))F FROM SALES_DATE GROUP BY SALES_NO ,WEEK_NO ORDER BY 1;

-- 교수 번호가 9903인 교수의 직급을 전임교수로,아이디를 'littlePascal'로 ,급여를 20올린 데이터로 수정

SELECT * FROM PROFESSOR p WHERE PROFNO =9903;
UPDATE PROFESSOR SET POSITION = '전임교수',USERID = 'litPascal',SAL = SAL+20 WHERE PROFNO = 9903; 

-- 학생테이블에서 컴퓨터 공학과에 소속된 모든학생들을 subquery를이용해 삭제해라

DELETE FROM STUDENT s WHERE DEPTNO =
(SELECT DEPTNO FROM DEPARTMENT d WHERE DNAME ='컴퓨터공학과');
SELECT * FROM STUDENT s ;

ROLLBACK;

CREATE TABLE T_STU AS SELECT * FROM STUDENT ;

SELECT * FROM T_STUDENT;

DROP TABLE T_STUDENT ;

RENAME T_STU TO T_STUDENT;

-- PROFESSOR_TEMP 테이블생성, 교수직급만 가져와서 생성
CREATE TABLE PROFESSOR_TEMP AS
SELECT * FROM PROFESSOR p WHERE "POSITION" = '교수';

SELECT * FROM PROFESSOR_TEMP;

UPDATE PROFESSOR_TEMP SET "POSITION" ='명예교수';

INSERT INTO PROFESSOR_TEMP VALUES (9999,'김도경','arom21','전임강사',200,SYSDATE,10,101);

MERGE INTO PROFESSOR p USING PROFESSOR_TEMP PT ON (P.PROFNO = PT.PROFNO) 
WHEN MATCHED THEN UPDATE SET P.POSITION = PT.POSITION
WHEN NOT MATCHED THEN INSERT VALUES(PT.PROFNO,PT.NAME,PT.USERID,PT.POSITION,PT.SAL,PT.HIREDATE,PT.COMM,PT.DEPTNO);

SELECT * FROM PROFESSOR p ;

DELETE FROM PROFESSOR p WHERE POSITION ='명예교수';
COMMIT;

----------SEQUENCE
---게시판용 테이블 생성
CREATE TABLE BOARD(
	NO NUMBER PRIMARY KEY,
	TITLE VARCHAR(4000),
	CONTENT CLOB,
	WRITER VARCHAR(1000),
	REGDATE DATE DEFAULT SYSDATE
);
CREATE SEQUENCE SEQ_BOARD;
SELECT * FROM BOARD;
DROP TABLE BOARD;
INSERT INTO BOARD(NO,TITLE,CONTENT,WRITER) VALUES(10,'제목','내용','새똥이');
INSERT INTO BOARD (NO, TITLE,CONTENT,WRITER) VALUES(SEQ_BOARD.NEXTVAL,'제목','내용','새똥이');

SELECT ROWNUM,B.* FROM BOARD B;

INSERT INTO BOARD(NO, TITLE,CONTENT,WRITER)
SELECT SEQ_BOARD.NEXTVAL,TITLE,CONTENT,WRITER FROM BOARD;
SELECT * FROM PROFESSOR p ;
SELECT * FROM STUDENT s ;
SELECT * FROM DEPARTMENT d ;
COMMIT;


--주소록 테이블생성

-- id varchar (100) , name varchar(100)
CREATE TABLE ADDR(
	ID VARCHAR2(100),
	NAME VARCHAR2(100)
);

ALTER TABLE ADDR2 ADD (BIRTH DATE);
SELECT * FROM ADDR;
-- 주소록에 컬럼추가 birth date
-- 주소록에 comment 컬럼추가 varchar2(200) 기본값 'NO COMMENT'
ALTER TABLE ADDR ADD (COMMENTS VARCHAR2(200) DEFAULT 'NO COMMENT');
SELECT * FROM ADDR;

INSERT INTO ADDR(ID) VALUES ('id1');

--주소록에 COMMENTS 컬럼 삭제

ALTER TABLE ADDR DROP (COMMENTS);
-- 주소록 ID 컬럼의 크기를 1BYTE로 변경
ALTER TABLE ADDR MODIFY (ID VARCHAR (10));

RENAME ADDR TO ADDR2;

---ADDR2 테이블에다가 '주소록' 이라는 COMMENT 추가

COMMENT ON TABLE ADDR2 IS '주소록';

SELECT * FROM ADDR2;

---ADDR2 NAME 컬럼에 '이름' 이라는 COMMENT 추가

COMMENT ON COLUMN ADDR2.NAME IS '이름';

-- 강좌 테이블 생성 (SUBJECT)
-- SUBNO 번호
-- SUBNAME 이름
-- TERM 학기 (1,2)
-- TYPE 필수여부 CHAR(1)

CREATE TABLE SUBJECT(
	SUBNO NUMBER CONSTRAINT SUBJECT_PK PRIMARY KEY,
	SUBNAME VARCHAR(200) CONSTRAINT SUBNAME_NN NOT NULL,
	TERM CHAR(1) CONSTRAINT TERM_CK CHECK (TERM IN ('1','2')),
	TYPE CHAR(1)
);
SELECT * FROM SUBJECT;
SELECT * FROM STUDENT s ;
DELETE STUDENT WHERE STUDNO = 10110;
ALTER TABLE STUDENT ADD CONSTRAINT STUDENT_PK PRIMARY KEY(STUDNO);

CREATE TABLE SUGANG (
	STUDNO CONSTRAINT SUGANG_STUDNO_FK REFERENCES STUDENT,
	SUBNO NUMBER,
	REGDATE DATE,
	RESULT NUMBER(3),
	CONSTRAINT SUGANG_SUBNO_FK  FOREIGN KEY(SUBNO) REFERENCES SUBJECT(SUBNO),
	CONSTRAINT SUGANG_PK PRIMARY KEY(STUDNO,SUBNO)
);

DROP TABLE SUGANG ;

--학과 테이블에 제약조건 넣기
-- pk : DEPTNO,DNAME : NN, COLLEGE <> DEPTNO FK
SELECT * FROM DEPARTMENT d ;
DROP TABLE DEPARTMENT ;


ALTER TABLE DEPARTMENT  MODIFY (DEPTNO CONSTRAINT DEPARTMENT_PK PRIMARY KEY);
ALTER TABLE DEPARTMENT  MODIFY (DNAME NOT NULL);
ALTER TABLE DEPARTMENT MODIFY (COLLEGE REFERENCES DEPARTMENT(DEPTNO));

--교수 테이블에 계약조건 넣기
-- PK, 이름NN , 아이디 UNIQUE
DROP TABLE PROFESSOR;
DROP TABLE STUDENT;
DROP TABLE DEPARTMENT ;



ALTER TABLE PROFESSOR ADD CONSTRAINT PROFESSOR_PK PRIMARY KEY(PROFNO);
ALTER TABLE PROFESSOR MODIFY (NAME NOT NULL);
ALTER TABLE PROFESSOR ADD CONSTRAINT PROF_USERID_UK UNIQUE(USERID);
ALTER TABLE PROFESSOR ADD FOREIGN KEY(DEPTNO) REFERENCES DEPARTMENT;


DROP TABLE STUDENT CASCADE CONSTRAINTS PURGE;
--DROP TABLE DEPARTMENT CASCADE CONSTRAINTS PURGE;
--DROP TABLE PROFESSOR ;

--학생
--이름 NN,아이디 UNIQUE,주민번호 UNIQUE, PK DEPTNO,FK PROFNO
SELECT * FROM STUDENT s ;
ALTER TABLE STUDENT MODIFY (NAME NOT NULL);
ALTER TABLE STUDENT MODIFY (USERID CONSTRAINT STUD_USERID_UK UNIQUE); -- COLUMN LEVER
ALTER TABLE STUDENT MODIFY (UNIQUE(IDNUM));
ALTER TABLE STUDENT MODIFY (DEPTNO REFERENCES DEPARTMENT);
ALTER TABLE STUDENT ADD FOREIGN KEY(PROFNO) REFERENCES PROFESSOR;

ROLLBACK;

COMMIT;

SELECT ROWID,ROWNUM FROM STUDENT s ;
-- DEPATEMENT DNAME 고유 인덱스 생성
CREATE UNIQUE INDEX IDX_DEPT_NAME ON DEPARTMENT(DNAME);

SELECT * FROM DEPARTMENT WHERE DNAME = '컴퓨터공학과';
-- oracle hint
SELECT /*INDEX(DEPARTMENT D)*/DNAME FROM DEPARTMENT ;

DROP INDEX IDX_DEPT_NAME;


--STUDENT BIRTHDATE에 비고유 인덱스 생성
CREATE INDEX IDX_STUD_BIRTHDATE ON STUDENT(BIRTHDATE);

--STUDEN테이블의 DEPTNO,GRADE에 결합인덱스 생성
SELECT /*INDEX(STUDENT)*/ DISTINCT GRADE,DEPTNO FROM STUDENT s ;
CREATE INDEX IDX_STUD_DEPTNO_GRADE ON STUDENT(DEPTNO,GRADE DESC);



--뷰

SELECT * FROM STUDENT s ;

CREATE VIEW VIEW_STUD AS
SELECT STUDNO,DEPTNO,NAME FROM STUDENT s ;

SELECT DEPTNO,COUNT(*) FROM VIEW_STUD WHERE DEPTNO != 201 GROUP BY DEPTNO;

INSERT INTO VIEW_STUD VALUES(12345,NULL,'홍길동');

SELECT * FROM (SELECT * FROM STUDENT);

CREATE OR REPLACE  VIEW VIEW_STUD AS SELECT STUDNO,NAME,USERID,DEPTNO FROM STUDENT s ;
SELECT * FROM VIEW_STUD;

CREATE FORCE VIEW VIEW_STUD2 AS 
SELECT * FROM STUDEN;

SELECT * FROM VIEW_STUD2;

SELECT * FROM STUDENT s ;
--학번, 이름, 학과번호 , 학과 이름으로 VIEW_STUD_DEPT라는 뷰를 작성
CREATE VIEW VIEW_STUD_DEPT AS
SELECT STUDNO,NAME,d.DEPTNO,DNAME FROM STUDENT s JOIN DEPARTMENT d ON d.DEPTNO = s.DEPTNO ;

---11111,고길동,101,컴퓨터공학과
INSERT INTO VIEW_STUD_DEPT VALUES(11111,'고길동',101,'컴퓨터공학과');


--학과별 인원수를 조회하여 VIEW_STUD_DEPT2 라는 이름의 VIEW 생성
CREATE VIEW VIEW_STUD_DEPT2(DNO,CNT) AS
SELECT DEPTNO,COUNT(*) FROM STUDENT GROUP BY DEPTNO ORDER BY 1;


--학과별 인원수를 조회하여 VIEW_STUD_DEPT2 라는 이름의 VIEW 생성
CREATE VIEW VIEW_STUD_DEPT2 AS
SELECT DEPTNO,COUNT(*) CNT FROM STUDENT GROUP BY DEPTNO ORDER BY 1;

SELECT * FROM VIEW_STUD_DEPT2;
DROP VIEW VIEW_STUD_DEPT2;

SELECT * FROM BOARD b ;

--ALTER SEQUENCE SEQ_BOARD START WITH 30;
DROP SEQUENCE SEQ_BOARD;
CREATE SEQUENCE SEQ_BOARD;

SELECT * FROM BOARD;

INSERT INTO BOARD(NO,TITLE,CONTENT,WRITER) VALUES(SEQ_BOARD.NEXTVAL,'제목' || SEQ_BOARD.CURRVAL,'내용','작성자');
INSERT INTO BOARD (NO,TITLE,CONTENT,WRITER)
SELECT SEQ_BOARD.NEXTVAL, TITLE ,CONTENT ,WRITER FROM BOARD;

SELECT SEQ_BOARD.NEXTVAL, TITLE ,CONTENT ,WRITER FROM BOARD;

--한페이지에 몇개씩?
SELECT * FROM(
SELECT ROWNUM RN,A.*
FROM(
SELECT B.* FROM BOARD B
--WHERE ROWNUM <=10 
ORDER BY 1 DESC) A 
)WHERE ROWNUM <= 30 AND RN > (4-1) * 10;
--WHERE ROWNUM <=10 AND ROWNUM <10;

SELECT * FROM (
SELECT /*+ INDEX_DESC(B SYS_C007010)*/B.*,ROWNUM RN
FROM BOARD B WHERE NO >0);

--더짧은코드
WITH A AS(SELECT /*+ INDEX_DESC(B SYS_C007010)*/B.*,ROWNUM RN
FROM BOARD B WHERE NO >0)SELECT * FROM A WHERE ROWNUM <=10 AND RN > 10;

--with 조인(알아보기)
WITH A AS(SELECT /*+ INDEX_DESC(B SYS_C007010)*/B.*,ROWNUM RN
FROM BOARD B WHERE NO >0)SELECT * FROM A WHERE ROWNUM <=10 AND RN > 10;


-- FILE SYSTEM
--FILE 권한

SELECT * FROM HR.EMPLOYEES ENP;


CREATE PUBLIC SYNONYM EMP FOR HR.EMPLOYEES;
SELECT * FROM EMP;

SELECT * FROM STU;

-- 사전
-- 접두어 : USER_ALL_DBA_

SELECT * FROM ALL_TABLES WHERE OWNER = 'SAMPLE';

SELECT * FROM USER_TAB_COLUMNS WHERE  TABLE_NAME = 'BOARD';

SELECT * FROM USER_CONSTRAINTS;

SELECT * FROM USER_INDEXES;

SELECT * FROM STUDENT s ;
